initSidebarItems({"fn":[["catch","Attempts to catch a panic from a given future. Note, however, that this is far from perfect, because if there are concurrent futures and any of them panicks, this function will catch their panic. Alternatively, one can think of `catch` as “catch any panic during the execution of the give future”."],["disable_hook_during_recovery","By default, even when recovering a panic, the hook previously used is still called. This function disables that hook while the returned RAII guard is not dropped."],["hook_during_recovery_enabled","Returns whether the previous hook should still be called during a recovery. This can be customized via [`disable_hook_during_recovery`]."]],"struct":[["DisableHookGuard","A guard of hook disabling. By default, even when recovering a panic, the hook previously used is still called. While this struct lives, produced by [`disable_hook_during_recovery`] function, and while there is a recovery in action, the previously used panic hook won’t be called. However, whenever this struct is dropped, it enables the previous hook again."],["Panic","An instance of a panic. Currently, this holds no data, but there a plans for making it hold panic payload."],["Recovery","An attempt to recover a future panic. This is a future that can be awaited for the next panic."]]});